# DATAâ€‘JSON.md â€“ Reference for the SPA build artefacts

> Generated by `scripts/build_data.py`. These four static files live in **`dist/data/`** and are fetched clientâ€‘side by the React app.

| File | Format | Typical size* | Records | Purpose |
|------|--------|---------------|---------|---------|
| **`entries.ndjson`** | NDJSON (1â€¯objectâ€¯/â€¯line) | â‰ˆâ€¯4â€¯MB | 20â€¯576 lines | Full dictionary corpus (search & entry view). |
| **`index.json`** | LunrÂ v2 serialization | â‰ˆâ€¯14â€¯MB | 20â€¯576 docs | Inâ€‘browser fullâ€‘text index powering the global Search bar. |
| **`graph.json`** | JSON | â‰ˆâ€¯1.4â€¯MB | 20â€¯576 nodes / 530 edges | Lemmaâ€‘variantâ€‘xref network for the Cytoscape view. |
| **`symbols.json`** | JSON array | â‰ˆâ€¯22â€¯kB | 294 glyphs | Symbol gallery: glyph â†’ linked entry IDs & counts. |

\*Sizes after gzip in production: **entries 290â€¯kB**, **index 1.1â€¯MB**, **graph 110â€¯kB**, **symbols 6â€¯kB**.

---

## 1Â Â `entries.ndjson`
Textâ€‘oriented master dataset. Each line is a selfâ€‘contained JSON object â€“ ideal for streaming or `jq` processing.

```jsonc
{
  "id": "sommerhoff_1701_entry_01234",       // stable; xml:id or fallback
  "source": "sommerhoff",                    // "ruland" | "sommerhoff"
  "lemma": "Crocus martis",
  "lemma_norm": "crocus martis",             // lowerâ€‘case, ASCII, collapsed
  "variants": "crocus veneris crocus ferreus", // spaceâ€‘joined list (original casing)
  "translations": "Eisenrost; Marcrocin",    // spaceâ€‘joined German quotes
  "definition": "â€¦ferrum praeparatum quodâ€¦",  // concatenated <def> content
  "symbols": ["crucible", "iron" ]            // id(s) from <g ref="#â€¦">
}
```

### Field semantics
| Field | Type | Notes |
|-------|------|-------|
| `id` | `string` | Prefer `xml:id`; else `@n`; else `source:index`. |
| `source` | `string` | Originating TEI file. |
| `lemma` | `string` | First `<form type='lemma'>` (including inline markup text). |
| `lemma_norm` | `string` | Normalised for lookâ€‘ups. |
| `variants` | `string` | Spaceâ€‘separated variants (may be empty). |
| `translations` | `string` | Spaceâ€‘separated German glosses. |
| `definition` | `string` | All `<def>` text concatenated. |
| `symbols` | `array[string]` | Symbol IDs (zeroâ€‘length if none). |

---

## 2Â Â `index.json`
A **LunrÂ v2** inverted index generated from the same entry records. The structure is considered opaque â€“ treat the file as a binary blob and hand it to `lunr.Index.load()` on the client:

```js
import lunr from "lunr";
const idx = lunr.Index.load(await fetchJSON("/data/index.json"));
const hits = idx.search("crocus martis");
```

Fields indexed: `lemma`, `lemma_norm`, `variants`, `translations`, `definition`. Reference field: `id`.

---

## 3Â Â `graph.json`
Topology for synonym and crossâ€‘reference visualisations.

```jsonc
{
  "nodes": [
    { "id": "ruland:57", "label": "Aqua fortis" },
    { "id": "sommerhoff:8935", "label": "Aqua fortis" }
  ],
  "edges": [
    { "source": "ruland:57", "target": "aqua fortis", "type": "variant" },
    { "source": "sommerhoff:8935", "target": "ruland:57", "type": "xref" }
  ]
}
```

### Edge types
| `type` value | Meaning |
|--------------|---------|
| `variant` | Connects a lemma node to each individual variant token (fast heuristic). |
| `xref` | â€œvideÂ â€¦â€ or other textual crossâ€‘reference detected in the definition. |

Client code typically pipes this into Cytoscape or visâ€‘network.

---

## 4Â Â `symbols.json`
Input for the Symbols explorer grid.

```jsonc
[
  {
    "id": "crucible",      // xml:id in <glyph>
    "glyph": "ğŸ©",          // printable Unicode; empty if unknown
    "entries": ["sommerhoff:312", "sommerhoff:987"],
    "count": 2              // redundant convenience field
  },
  â€¦
]
```

### Notes
* The order is **descending by `count`**, so the front end can simply render in array order.
* If `glyph` is `""`, show a placeholder (e.g. â–¢) or sprite fallback.

---

## 5Â Â Crossâ€‘file relationships
* `entries.ndjson.symbols` â†” **`symbols.json.id`** (1â€¯:â€¯*).  
  Enables â€œshow me every entry containing ğŸ©â€.
* `graph.json.nodes.id` is always present in `entries.ndjson.id`.
* `index.json` uses the *same* `id` values as primary keys, so a Lunr hit can be resolved to the entry payload instantly.

---

###Â Versioning & reproducibility
The JSON artefacts are **pure functions** of the two TEI sources plus `build_data.py`.  Reâ€‘running the script with the same inputs produces byteâ€‘identical files (guaranteed by deterministic node ordering and stable IDs).