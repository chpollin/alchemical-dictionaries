# DATA‑JSON.md – Reference for the SPA build artefacts

> Generated by `scripts/build_data.py`. These four static files live in **`dist/data/`** and are fetched client‑side by the React app.

| File | Format | Typical size* | Records | Purpose |
|------|--------|---------------|---------|---------|
| **`entries.ndjson`** | NDJSON (1 object / line) | ≈ 4 MB | 20 576 lines | Full dictionary corpus (search & entry view). |
| **`index.json`** | Lunr v2 serialization | ≈ 14 MB | 20 576 docs | In‑browser full‑text index powering the global Search bar. |
| **`graph.json`** | JSON | ≈ 1.4 MB | 20 576 nodes / 530 edges | Lemma‑variant‑xref network for the Cytoscape view. |
| **`symbols.json`** | JSON array | ≈ 22 kB | 294 glyphs | Symbol gallery: glyph → linked entry IDs & counts. |

\*Sizes after gzip in production: **entries 290 kB**, **index 1.1 MB**, **graph 110 kB**, **symbols 6 kB**.

---

## 1  `entries.ndjson`
Text‑oriented master dataset. Each line is a self‑contained JSON object – ideal for streaming or `jq` processing.

```jsonc
{
  "id": "sommerhoff_1701_entry_01234",       // stable; xml:id or fallback
  "source": "sommerhoff",                    // "ruland" | "sommerhoff"
  "lemma": "Crocus martis",
  "lemma_norm": "crocus martis",             // lower‑case, ASCII, collapsed
  "variants": "crocus veneris crocus ferreus", // space‑joined list (original casing)
  "translations": "Eisenrost; Marcrocin",    // space‑joined German quotes
  "definition": "…ferrum praeparatum quod…",  // concatenated <def> content
  "symbols": ["crucible", "iron" ]            // id(s) from <g ref="#…">
}
```

### Field semantics
| Field | Type | Notes |
|-------|------|-------|
| `id` | `string` | Prefer `xml:id`; else `@n`; else `source:index`. |
| `source` | `string` | Originating TEI file. |
| `lemma` | `string` | First `<form type='lemma'>` (including inline markup text). |
| `lemma_norm` | `string` | Normalised for look‑ups. |
| `variants` | `string` | Space‑separated variants (may be empty). |
| `translations` | `string` | Space‑separated German glosses. |
| `definition` | `string` | All `<def>` text concatenated. |
| `symbols` | `array[string]` | Symbol IDs (zero‑length if none). |

---

## 2  `index.json`
A **Lunr v2** inverted index generated from the same entry records. The structure is considered opaque – treat the file as a binary blob and hand it to `lunr.Index.load()` on the client:

```js
import lunr from "lunr";
const idx = lunr.Index.load(await fetchJSON("/data/index.json"));
const hits = idx.search("crocus martis");
```

Fields indexed: `lemma`, `lemma_norm`, `variants`, `translations`, `definition`. Reference field: `id`.

---

## 3  `graph.json`
Topology for synonym and cross‑reference visualisations.

```jsonc
{
  "nodes": [
    { "id": "ruland:57", "label": "Aqua fortis" },
    { "id": "sommerhoff:8935", "label": "Aqua fortis" }
  ],
  "edges": [
    { "source": "ruland:57", "target": "aqua fortis", "type": "variant" },
    { "source": "sommerhoff:8935", "target": "ruland:57", "type": "xref" }
  ]
}
```

### Edge types
| `type` value | Meaning |
|--------------|---------|
| `variant` | Connects a lemma node to each individual variant token (fast heuristic). |
| `xref` | “vide …” or other textual cross‑reference detected in the definition. |

Client code typically pipes this into Cytoscape or vis‑network.

---

## 4  `symbols.json`
Input for the Symbols explorer grid.

```jsonc
[
  {
    "id": "crucible",      // xml:id in <glyph>
    "glyph": "🝩",          // printable Unicode; empty if unknown
    "entries": ["sommerhoff:312", "sommerhoff:987"],
    "count": 2              // redundant convenience field
  },
  …
]
```

### Notes
* The order is **descending by `count`**, so the front end can simply render in array order.
* If `glyph` is `""`, show a placeholder (e.g. ▢) or sprite fallback.

---

## 5  Cross‑file relationships
* `entries.ndjson.symbols` ↔ **`symbols.json.id`** (1 : *).  
  Enables “show me every entry containing 🝩”.
* `graph.json.nodes.id` is always present in `entries.ndjson.id`.
* `index.json` uses the *same* `id` values as primary keys, so a Lunr hit can be resolved to the entry payload instantly.

---

### Versioning & reproducibility
The JSON artefacts are **pure functions** of the two TEI sources plus `build_data.py`.  Re‑running the script with the same inputs produces byte‑identical files (guaranteed by deterministic node ordering and stable IDs).